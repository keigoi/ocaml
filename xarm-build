#!/bin/sh
set -e
#
# Build OCamlXARM, OCaml cross-compiler for iOS based on OCaml 4.00.0
#
# Jeffrey Scofield, jeffsco@psellos.com
#
# Copyright (c) 2012 Psellos   http://psellos.com/
# Licensed under the MIT License:
#     http://www.opensource.org/licenses/mit-license.php
#
# Page of OCaml-on-iOS resources: http://psellos.com/ocaml/
#
# Expects one parameter:
# Single big step:  all
# Medium steps:     phase1           phase2
# Small steps:      config1  build1  config2  build2

# We use fancy features of the sed that comes with OS X.  For now,
# specify full path.  If this becomes a problem, stop using the fancy
# features.
#
SED=/usr/bin/sed

export PLT=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform
export SDK=/Developer/SDKs/iPhoneOS6.1.sdk
export SIMPLT=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform
export SIMSDK=/Developer/SDKs/iPhoneSimulator6.1.sdk
export XARMTARGET=/usr/local/ocamlxarm
export OSXARCH=i386

# Small steps
config1 () {
    # Configure for building bytecode interpreter to run on Intel OS X.
    # But specify ARM architecture for assembly and partial link.
    echo 'xarm-build: ----- configure phase 1 -----'
    ./configure \
            -bindir $XARMTARGET/v7/bin \
            -libdir $XARMTARGET/v7/lib/ocaml \
            -mandir $XARMTARGET/v7/man/man1 \
            -no-curses \
            -no-tk \
            -no-graph \
            -host i386-apple-darwin11.3.0 \
            -cc "gcc -arch $OSXARCH" \
            -as "$PLT/Developer/usr/bin/llvm-gcc-4.2 -arch armv7 -c" \
            -aspp "$PLT/Developer/usr/bin/llvm-gcc-4.2 -arch armv7 -c"
    # Post-modify config/Makefile to select the ARM back end for
    # ocamlopt (to generate ARM assembly code).
    $SED -i .bak \
        -e '1i\
# modified by xarm-build for OCamlXARM' \
        -e 's/^ARCH[    ]*=.*/ARCH=arm/' \
        -e 's/^MODEL[    ]*=.*/MODEL=armv7/' \
        -e "s#^PARTIALLD[    ]*=.*#PARTIALLD=$PLT/Developer/usr/bin/ld -r#" \
        config/Makefile
    # Post-modify utils/config.ml to tell ocamlopt to create ARM
    # binaries for itself.  Also tell ocamlc and ocamlopt to use ARM
    # architecture when compiling C files.
    make utils/config.ml
    $SED -i .bak \
        -e 's#let[ 	][ 	]*mkexe[ 	]*=.*#let mkexe ="'"$PLT/Developer/usr/bin/gcc -arch armv7 -isysroot $PLT$SDK"'"#' \
        -e 's#let[ 	][ 	]*bytecomp_c_compiler[ 	]*=.*#let bytecomp_c_compiler ="'"$PLT/Developer/usr/bin/gcc -arch armv7 -isysroot $PLT$SDK"'"#' \
        -e 's#let[ 	][ 	]*native_c_compiler[ 	]*=.*#let native_c_compiler ="'"$PLT/Developer/usr/bin/gcc -arch armv7 -isysroot $PLT$SDK"'"#' \
        utils/config.ml
}

build1 () {
    # Don't assemble asmrun/arm.S for Phase 1 build.  Modify Makefile
    # temporarily to disable.  Be really sure to put back for Phase 2.
    echo 'xarm-build: ----- build phase 1 -----'
    trap 'mv -f asmrun/Makefile.aside asmrun/Makefile' EXIT
    grep -q '^[         ]*ASMOBJS[      ]*=' asmrun/Makefile && \
        mv -f asmrun/Makefile asmrun/Makefile.aside
    $SED -e '/^[        ]*ASMOBJS[      ]*=/s/^/#/' \
        asmrun/Makefile.aside > asmrun/Makefile
    make -j8 world && make -j8 opt
    mv -f asmrun/Makefile.aside asmrun/Makefile
    trap - EXIT
    # Save the Phase 1 shared (dynamically loadable) libraries and
    # restore them after Phase 2.  They're required by some OCaml
    # utilities, such as camlp4.
    #
    # The shared libraries are useful only with the bytecode
    # interpreter, which we don't support under iOS.  This lets us (just
    # barely) fit OCamlXARM into the form of a usual OCaml release.
    find . -name '*.so' -exec mv {} {}phase1 \;
}

config2 () {
    # Clean out OS X runtime
    echo 'xarm-build: ----- configure phase 2 -----'
    cd asmrun; make clean; cd ..
    cd stdlib; make clean; cd ..
    cd otherlibs/bigarray; make clean; cd ../..
    cd otherlibs/dynlink; make clean; cd ../..
    cd otherlibs/num; make clean; cd ../..
    cd otherlibs/str; make clean; cd ../..
    cd otherlibs/systhreads; make clean; cd ../..
    cd otherlibs/threads; make clean; cd ../..
    cd otherlibs/unix; make clean; cd ../..
    # Reconfigure for iOS environment, using iOS Simulator to test the
    # ABI.
    ./configure \
            -bindir $XARMTARGET/v7/bin \
            -libdir $XARMTARGET/v7/lib/ocaml \
            -mandir $XARMTARGET/v7/man/man1 \
            -no-curses \
            -no-tk \
            -no-graph \
            -host arm-apple-darwin10.0.0d3 \
            -cc "gcc -arch i386 -isysroot $SIMPLT$SIMSDK" \
            -as "gcc -arch i386 -c" \
            -aspp "gcc -arch i386 -c" \
            -lib "-Wl,-syslibroot,$SIMPLT$SIMSDK"
    # Post-modify config/Makefile to specify the real cross-compiling
    # toolchain.
    $SED -i .bak \
        -e '1i\
# modified by xarm-build for OCamlXARM' \
        -e "s|^BYTECC[    ]*=.*|BYTECC=$PLT/Developer/usr/bin/gcc -arch armv7 -isysroot $PLT$SDK|" \
        -e "s|^BYTECCLIBS[    ]*=.*|BYTECCLIBS=-Wl,-syslibroot,$PLT$SDK|" \
        -e 's/^ARCH[    ]*=.*/ARCH=arm/' \
        -e 's/^MODEL[    ]*=.*/MODEL=armv7/' \
        -e 's/^SYSTEM[    ]*=.*/SYSTEM=macosx/' \
        -e "s|^NATIVECC[    ]*=.*|NATIVECC=$PLT/Developer/usr/bin/gcc -arch armv7 -isysroot $PLT$SDK|" \
        -e "s|^NATIVECCLIBS[    ]*=.*|NATIVECCLIBS=-Wl,-syslibroot,$PLT$SDK|" \
        -e "s|^ASM[     ]*=.*|ASM=$PLT/Developer/usr/bin/gcc -arch armv7 -c|" \
        -e "s|^ASPP[     ]*=.*|ASPP=$PLT/Developer/usr/bin/gcc -arch armv7 -c|" \
        -e "s|^MKDLL[   ]*=.*|MKDLL=$PLT/Developer/usr/bin/gcc -arch armv7 -isysroot $PLT$SDK -bundle -flat_namespace -undefined suppress|" \
        -e "s|^MKMAINDLL[   ]*=.*|MKMAINDLL=$PLT/Developer/usr/bin/gcc -arch armv7 -isysroot $PLT$SDK -bundle -flat_namespace -undefined suppress|" \
        config/Makefile
    # Rebuild ocamlmklib, so libraries work with iOS.
    rm myocamlbuild_config.ml
    cd tools
    make ocamlmklib
    cd ..
}

build2 () {
    # Make iOS runtime
    echo 'xarm-build: ----- build phase 2 -----'
    cd asmrun; make -j8 all; cd ..
    cd stdlib; make -j8 all allopt; cd ..
    cd otherlibs/unix; make -j8 all allopt; cd ../..
    cd otherlibs/str; make -j8 all allopt; cd ../..
    cd otherlibs/num; make -j8 all allopt; cd ../..
    cd otherlibs/dynlink; make -j8 all allopt; cd ../..
    cd otherlibs/bigarray; make -j8 all allopt; cd ../..
    cd otherlibs/systhreads; make -j8 all allopt; cd ../..
    cd otherlibs/threads; make -j8 all allopt; cd ../..
    # Restore the saved Phase 1 .so files (see above).
    find . -name '*.sophase1' -print | \
        while read f; do \
            fso="$(expr "$f" : '\(.*\)sophase1$')so"; mv -f $f $fso; \
        done
}

# Bigger steps

phase1 () {
    config1 && build1
}

phase2 () {
    config2 && build2
}

all () {
    phase1 && phase2
}

clean () {
    rm -f myocamlbuild_config.ml
    make clean
}

case "$1" in
config1) config1 ;;
build1) build1 ;;
config2) config2 ;;
build2) build2 ;;
phase1) phase1 ;;
phase2) phase2 ;;
all) all ;;
clean) clean ;;
*) echo "usage: $(basename $0) {all|phase1|phase2|config1|build1|config2|build2}" >&2;
   echo "       $(basename $0) clean" >&2;
   exit 1
   ;;
esac
